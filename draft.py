from pprint import pprint

# Example of board with two filled lines
# Numbers may define colors
board_example = [['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
                 ['0', '0', '1', '1', '1', '1', '1', '0', '0', '0'],
                 ['0', '1', '1', '1', '2', '2', '1', '1', '1', '1'],
                 ['1', '1', '1', '1', '2', '2', '1', '1', '1', '1'],
                 ['1', '1', '1', '1', '1', '1', '1', '1', '1', '1']]


# ------------------------------------------
# Base logic functions:
def destroy_filed_lines(board):
    new_board = board.copy()
    for line in board:
        if line.count('0') == 0:
            del new_board[new_board.index(line)]
            new_board.insert(0, ['0'] * 10)
    return new_board


edited_board = destroy_filed_lines(board_example)
pprint(edited_board)

print(len(board_example) == len(edited_board))
print(len(board_example[0]) == len(edited_board[0]))
# True -> sizes stayed the same

# ------------------------------------------

# Draft:
'''
Well, I just realised that it will be pretty pointless to write following in English, so it will 
be in Russian (at least this time)
But hope you don't mind that short notes in English, because for me it's kinda a habit already

Я тут решил +- описать логику игры, чтобы было под рукой. Если что - вноси сюда же правки.

В общем, для начала я бы предложил отказаться от "ступенчатого" спуска блоков и сделать его 
плавным. Да немного непривычно для тетриса, но будет проще технически (скорее всего), 
да и смотреться будет приятнее. Но надо будет потестить.
Касания я предлагаю проверять просто через spritecollide, если получиться - с небольшой задержкой. 
Потом превращать это всё в сетку, как на примере выше.

Единственное, что я пока не до конца понимаю как реализовывать - удаление линий на экране. 
Единственная идея, которая у меня пока есть - разбивать уже приземлившиеся блоки на спрайты 
поменьше (в одну клетку) и работать уже с ними.
Только что появилась вторая идея. Вообще забыть, что приземлившиеся блоки - целые спрайты и 
зарисовывать клетки идентичным спрайту цветом, основываясь на цветовых кодах в списке. То есть пока 
блок падает - он целый спрайт. По приземлению он будет отрисовываться как несколько отдельных 
спрайтов, размером в клетку.
'''
